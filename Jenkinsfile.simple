pipeline {
    agent any
    
    environment {
        APP_NAME = 'file-storage-app'
        DEPLOY_DIR = '/home/ubuntu/app'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 20, unit: 'MINUTES')
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Checking out code from GitHub...'
                checkout scm
                sh 'git rev-parse --short HEAD > .git/commit-hash'
                script {
                    env.GIT_COMMIT_HASH = readFile('.git/commit-hash').trim()
                    echo "Building commit: ${env.GIT_COMMIT_HASH}"
                }
            }
        }
        
        stage('Environment Check') {
            steps {
                echo 'üîß Checking environment...'
                sh '''
                    echo "Node version:"
                    node --version || echo "Node not in PATH"
                    echo "Docker version:"
                    docker --version
                    echo "Workspace: ${WORKSPACE}"
                '''
            }
        }
        
        stage('Install Dependencies & Build') {
            steps {
                echo 'üìö Installing dependencies and building...'
                nodejs(nodeJSInstallationName: 'NodeJS-20') {
                    sh '''
                        # Install pnpm if not present
                        if ! command -v pnpm &> /dev/null; then
                            echo "Installing pnpm..."
                            npm install -g pnpm
                        fi
                        
                        # Install dependencies
                        pnpm install --frozen-lockfile
                        
                        # Create .env file with required variables
                        # Jenkins container can't access host filesystem, so we create it here
                        echo "Creating .env file with build-time variables..."
                        cat > .env << 'ENVFILE'
# Placeholder .env for build - runtime values loaded from host
NEXT_PUBLIC_SUPABASE_URL=https://placeholder.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NDUxOTI4MDAsImV4cCI6MTk2MDc2ODgwMH0.placeholder
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY0NTE5MjgwMCwiZXhwIjoxOTYwNzY4ODAwfQ.placeholder
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
AWS_S3_BUCKET_NAME=placeholder-bucket
AWS_REGION=us-east-1
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=placeholder-secret-key-for-build-only
RESEND_API_KEY=re_placeholder_key
EMAIL_FROM=noreply@example.com
NEXT_PUBLIC_APP_URL=http://localhost:3000
ENVFILE
                        
                        echo ".env file created for build"
                        
                        # Build Next.js app
                        pnpm build
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'üê≥ Building Docker image...'
                sh """
                    # Build the image from current workspace
                    docker build -t ${APP_NAME}:latest .
                    
                    # Show image info
                    docker images ${APP_NAME}:latest
                """
            }
        }
        
        stage('Deploy') {
            steps {
                echo 'üöÄ Deploying application...'
                sh """
                    # Stop and remove old container
                    docker stop ${APP_NAME} || true
                    docker rm ${APP_NAME} || true
                    
                    # Copy .env file from deploy directory to workspace for Docker access
                    if [ -f ${DEPLOY_DIR}/.env ]; then
                        cp ${DEPLOY_DIR}/.env ${WORKSPACE}/.env
                        echo "‚úÖ .env file copied from ${DEPLOY_DIR}/.env"
                    else
                        echo "‚ùå ERROR: .env file not found at ${DEPLOY_DIR}/.env"
                        echo "Please create the file with: nano ${DEPLOY_DIR}/.env"
                        exit 1
                    fi
                    
                    # Create Docker network if it doesn't exist
                    if ! docker network ls | grep -q app-network; then
                        echo "Creating app-network..."
                        docker network create app-network
                    else
                        echo "Network app-network already exists"
                    fi
                    
                    # Start new container with updated image
                    echo "Starting container with env file..."
                    docker run -d \\
                        --name ${APP_NAME} \\
                        --network app-network \\
                        -p 3000:3000 \\
                        --env-file ${WORKSPACE}/.env \\
                        --restart always \\
                        ${APP_NAME}:latest
                    
                    # Wait for startup
                    echo "Waiting for application to start..."
                    sleep 15
                    
                    # Check container status
                    docker ps | grep ${APP_NAME}
                """
            }
        }
        
        stage('Health Check') {
            steps {
                echo 'üè• Running health checks...'
                sh """
                    # Wait a bit more
                    sleep 5
                    
                    # Check if container is running
                    if ! docker ps | grep -q ${APP_NAME}; then
                        echo "Container not running!"
                        docker logs ${APP_NAME}
                        exit 1
                    fi
                    
                    # Test homepage using container name on app-network
                    echo "Testing homepage via container network..."
                    docker run --rm --network app-network alpine/curl:latest \
                        curl -f http://${APP_NAME}:3000/ > /dev/null || {
                        echo "Homepage check failed!"
                        docker logs ${APP_NAME} --tail=50
                        exit 1
                    }
                    
                    echo "‚úÖ Health check passed!"
                    docker logs ${APP_NAME} --tail=20
                """
            }
        }
        
        stage('Cleanup') {
            steps {
                echo 'üßπ Cleaning up old images...'
                sh '''
                    # Remove dangling images
                    docker image prune -f
                    
                    # Show disk usage
                    docker system df
                '''
            }
        }
    }
    
    post {
        success {
            echo '‚úÖ =================================='
            echo '‚úÖ Pipeline completed successfully!'
            echo '‚úÖ Application deployed and running'
            echo '‚úÖ =================================='
        }
        
        failure {
            echo '‚ùå =================================='
            echo '‚ùå Pipeline failed!'
            echo '‚ùå Check logs above for details'
            echo '‚ùå =================================='
            sh """
                echo "Container logs:"
                docker logs ${APP_NAME} --tail=50 || true
            """
        }
        
        always {
            echo 'üìä Build summary:'
            sh '''
                echo "Workspace size:"
                du -sh ${WORKSPACE} || true
            '''
        }
    }
}
