pipeline {
    agent any
    
    environment {
        APP_NAME = 'file-storage-app'
        DEPLOY_DIR = '/home/ubuntu/app'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 20, unit: 'MINUTES')
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'ðŸ“¦ Checking out code from GitHub...'
                checkout scm
                // Force pull latest changes
                sh '''
                    git fetch origin main
                    git reset --hard origin/main
                '''
                sh 'git rev-parse --short HEAD > .git/commit-hash'
                script {
                    env.GIT_COMMIT_HASH = readFile('.git/commit-hash').trim()
                    echo "Building commit: ${env.GIT_COMMIT_HASH}"
                }
            }
        }
        
        stage('Environment Check') {
            steps {
                echo 'ðŸ”§ Checking environment...'
                sh '''
                    echo "Node version:"
                    node --version || echo "Node not in PATH"
                    echo "Docker version:"
                    docker --version
                    echo "Workspace: ${WORKSPACE}"
                '''
            }
        }
        
        stage('Install Dependencies & Build') {
            steps {
                echo 'ðŸ“š Installing dependencies and building...'
                nodejs(nodeJSInstallationName: 'NodeJS-20') {
                    sh '''
                        # Install pnpm if not present
                        if ! command -v pnpm &> /dev/null; then
                            echo "Installing pnpm..."
                            npm install -g pnpm
                        fi
                        
                        # Install dependencies
                        pnpm install --frozen-lockfile
                        
                        # Create .env file with required variables for build
                        # Jenkins container can't access host filesystem, so we create it here
                        # Note: Actual runtime values are loaded from /home/ubuntu/app/.env during deployment
                        echo "Creating .env file with build-time placeholders..."
                        cat > .env << 'ENVFILE'
# Build-time placeholders - actual values loaded from /home/ubuntu/app/.env during deployment
NEXT_PUBLIC_SUPABASE_URL=https://placeholder.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.placeholder
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.placeholder
AWS_ACCESS_KEY_ID=placeholder
AWS_SECRET_ACCESS_KEY=placeholder
AWS_S3_BUCKET_NAME=file-storage-app-2025
AWS_REGION=us-east-1
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=placeholder-secret-for-build-only
RESEND_API_KEY=re_placeholder
EMAIL_FROM=noreply@example.com
NEXT_PUBLIC_APP_URL=http://localhost:3000
NODE_ENV=production
ENVFILE
                        
                        echo ".env file created for build"
                        
                        # Build Next.js app
                        pnpm build
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'ðŸ³ Building Docker image...'
                sh """
                    # Remove old image to force fresh build
                    docker rmi ${APP_NAME}:latest || true
                    
                    # Build the image from current workspace
                    docker build -t ${APP_NAME}:latest .
                    
                    # Show image info
                    docker images ${APP_NAME}:latest
                """
            }
        }
        
        stage('Deploy') {
            steps {
                echo 'ðŸš€ Deploying application...'
                sh """
                    # Stop and remove old container
                    docker stop ${APP_NAME} || true
                    docker rm ${APP_NAME} || true
                    
                    # Copy .env file from deploy directory to workspace for Docker access
                    if [ -f ${DEPLOY_DIR}/.env ]; then
                        cp ${DEPLOY_DIR}/.env ${WORKSPACE}/.env
                        echo "âœ… .env file copied from ${DEPLOY_DIR}/.env"
                    else
                        echo "âŒ ERROR: .env file not found at ${DEPLOY_DIR}/.env"
                        echo "Please create the file with: nano ${DEPLOY_DIR}/.env"
                        exit 1
                    fi
                    
                    # Start new container with updated image
                    # Note: Using host network mode for simplicity (Jenkins can't access docker-compose networks)
                    echo "Starting container with env file..."
                    docker run -d \\
                        --name ${APP_NAME} \\
                        --network host \\
                        --env-file ${WORKSPACE}/.env \\
                        --restart always \\
                        ${APP_NAME}:latest
                    
                    # Wait for startup
                    echo "Waiting for application to start..."
                    sleep 15
                    
                    # Check container status
                    docker ps | grep ${APP_NAME}
                """
            }
        }
        
        stage('Health Check') {
            steps {
                echo 'ðŸ¥ Running health checks...'
                sh '''
                    # Wait for app startup
                    sleep 10
                    
                    # Check if container is running
                    if ! docker ps | grep -q file-storage-app; then
                        echo "âŒ Container not running!"
                        docker logs file-storage-app
                        exit 1
                    fi
                    
                    echo "âœ… Container is running"
                    
                    # Since Jenkins is in a container, we need to use docker exec to test from inside the app container
                    echo "Testing application from inside container..."
                    
                    if docker exec file-storage-app sh -c "curl -s -o /dev/null -w '%{http_code}' http://localhost:3000/" | grep -q "200\\|301\\|302"; then
                        echo "âœ… Health check passed! App is responding."
                        docker logs file-storage-app --tail=10
                    else
                        echo "âŒ Health check failed!"
                        echo "Trying verbose check..."
                        docker exec file-storage-app sh -c "curl -v http://localhost:3000/" || true
                        echo ""
                        echo "Container logs:"
                        docker logs file-storage-app --tail=50
                        exit 1
                    fi
                    
                    echo "âœ… Application is healthy and ready!"
                '''
            }
        }
        
        stage('Cleanup') {
            steps {
                echo 'ðŸ§¹ Cleaning up old images...'
                sh '''
                    # Remove dangling images
                    docker image prune -f
                    
                    # Show disk usage
                    docker system df
                '''
            }
        }
    }
    
    post {
        success {
            echo 'âœ… =================================='
            echo 'âœ… Pipeline completed successfully!'
            echo 'âœ… Application deployed and running'
            echo 'âœ… =================================='
        }
        
        failure {
            echo 'âŒ =================================='
            echo 'âŒ Pipeline failed!'
            echo 'âŒ Check logs above for details'
            echo 'âŒ =================================='
            sh """
                echo "Container logs:"
                docker logs ${APP_NAME} --tail=50 || true
            """
        }
        
        always {
            echo 'ðŸ“Š Build summary:'
            sh '''
                echo "Workspace size:"
                du -sh ${WORKSPACE} || true
            '''
        }
    }
}
