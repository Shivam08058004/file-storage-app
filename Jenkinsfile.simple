pipeline {
    agent any
    
    environment {
        APP_NAME = 'file-storage-app'
        DEPLOY_DIR = '/home/ubuntu/app'
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 20, unit: 'MINUTES')
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'ðŸ“¦ Checking out code from GitHub...'
                checkout scm
                // Force pull latest changes
                sh '''
                    git fetch origin main
                    git reset --hard origin/main
                '''
                sh 'git rev-parse --short HEAD > .git/commit-hash'
                script {
                    env.GIT_COMMIT_HASH = readFile('.git/commit-hash').trim()
                    echo "Building commit: ${env.GIT_COMMIT_HASH}"
                }
            }
        }
        
        stage('Environment Check') {
            steps {
                echo 'ðŸ”§ Checking environment...'
                sh '''
                    echo "Node version:"
                    node --version || echo "Node not in PATH"
                    echo "Docker version:"
                    docker --version
                    echo "Workspace: ${WORKSPACE}"
                '''
            }
        }
        
        stage('Install Dependencies & Build') {
            steps {
                echo 'ðŸ“š Installing dependencies and building...'
                nodejs(nodeJSInstallationName: 'NodeJS-20') {
                    sh '''
                        # Install pnpm if not present
                        if ! command -v pnpm &> /dev/null; then
                            echo "Installing pnpm..."
                            npm install -g pnpm
                        fi
                        
                        # Install dependencies
                        pnpm install --frozen-lockfile
                        
                        # Create .env file with required variables
                        # Jenkins container can't access host filesystem, so we create it here
                        echo "Creating .env file with build-time variables..."
                        cat > .env << 'ENVFILE'
# Placeholder .env for build - runtime values loaded from host
NEXT_PUBLIC_SUPABASE_URL=https://placeholder.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6ImFub24iLCJpYXQiOjE2NDUxOTI4MDAsImV4cCI6MTk2MDc2ODgwMH0.placeholder
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBsYWNlaG9sZGVyIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTY0NTE5MjgwMCwiZXhwIjoxOTYwNzY4ODAwfQ.placeholder
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
AWS_S3_BUCKET_NAME=placeholder-bucket
AWS_REGION=us-east-1
NEXTAUTH_URL=http://localhost:3000
NEXTAUTH_SECRET=placeholder-secret-key-for-build-only
RESEND_API_KEY=re_placeholder_key
EMAIL_FROM=noreply@example.com
NEXT_PUBLIC_APP_URL=http://localhost:3000
ENVFILE
                        
                        echo ".env file created for build"
                        
                        # Build Next.js app
                        pnpm build
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'ðŸ³ Building Docker image...'
                sh """
                    # Remove old image to force fresh build
                    docker rmi ${APP_NAME}:latest || true
                    
                    # Build the image from current workspace
                    docker build -t ${APP_NAME}:latest .
                    
                    # Show image info
                    docker images ${APP_NAME}:latest
                """
            }
        }
        
        stage('Deploy') {
            steps {
                echo 'ðŸš€ Deploying application...'
                sh """
                    # Stop and remove old container
                    docker stop ${APP_NAME} || true
                    docker rm ${APP_NAME} || true
                    
                    # Copy .env file from deploy directory to workspace for Docker access
                    if [ -f ${DEPLOY_DIR}/.env ]; then
                        cp ${DEPLOY_DIR}/.env ${WORKSPACE}/.env
                        echo "âœ… .env file copied from ${DEPLOY_DIR}/.env"
                    else
                        echo "âŒ ERROR: .env file not found at ${DEPLOY_DIR}/.env"
                        echo "Please create the file with: nano ${DEPLOY_DIR}/.env"
                        exit 1
                    fi
                    
                    # Start new container with updated image
                    # Note: Using host network mode for simplicity (Jenkins can't access docker-compose networks)
                    echo "Starting container with env file..."
                    docker run -d \\
                        --name ${APP_NAME} \\
                        --network host \\
                        --env-file ${WORKSPACE}/.env \\
                        --restart always \\
                        ${APP_NAME}:latest
                    
                    # Wait for startup
                    echo "Waiting for application to start..."
                    sleep 15
                    
                    # Check container status
                    docker ps | grep ${APP_NAME}
                """
            }
        }
        
        stage('Health Check') {
            steps {
                echo 'ðŸ¥ Running health checks...'
                sh """
                    # Wait for app startup
                    sleep 10
                    
                    # Check if container is running
                    if ! docker ps | grep -q ${APP_NAME}; then
                        echo "âŒ Container not running!"
                        docker logs ${APP_NAME}
                        exit 1
                    fi
                    
                    echo "âœ… Container is running"
                    
                    # Test homepage using localhost (since we're using host network)
                    echo "Testing homepage on localhost:3000..."
                    
                    # Try curl with verbose output to debug
                    RESPONSE=\$(curl -v http://localhost:3000/ 2>&1)
                    CURL_EXIT=\$?
                    
                    echo "Curl response:"
                    echo "\$RESPONSE"
                    echo "Curl exit code: \$CURL_EXIT"
                    
                    # Accept both successful response (0) and "failed to verify" (60) as OK
                    # since we're testing connectivity, not SSL
                    if [ \$CURL_EXIT -eq 0 ] || [ \$CURL_EXIT -eq 52 ] || echo "\$RESPONSE" | grep -q "HTTP\|<html\|doctype"; then
                        echo "âœ… Health check passed! App is responding."
                    else
                        echo "âŒ Health check failed! App not responding properly."
                        echo "Container logs:"
                        docker logs ${APP_NAME} --tail=50
                        exit 1
                    fi
                    
                    echo "âœ… Application is healthy and ready!"
                """
            }
        }
        
        stage('Cleanup') {
            steps {
                echo 'ðŸ§¹ Cleaning up old images...'
                sh '''
                    # Remove dangling images
                    docker image prune -f
                    
                    # Show disk usage
                    docker system df
                '''
            }
        }
    }
    
    post {
        success {
            echo 'âœ… =================================='
            echo 'âœ… Pipeline completed successfully!'
            echo 'âœ… Application deployed and running'
            echo 'âœ… =================================='
        }
        
        failure {
            echo 'âŒ =================================='
            echo 'âŒ Pipeline failed!'
            echo 'âŒ Check logs above for details'
            echo 'âŒ =================================='
            sh """
                echo "Container logs:"
                docker logs ${APP_NAME} --tail=50 || true
            """
        }
        
        always {
            echo 'ðŸ“Š Build summary:'
            sh '''
                echo "Workspace size:"
                du -sh ${WORKSPACE} || true
            '''
        }
    }
}
